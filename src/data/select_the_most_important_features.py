import os
import sys
import pandas as pd

# Dodaj ścieżkę projektu do sys.path, aby umożliwić importy z src
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '../..'))
if project_root not in sys.path:
    sys.path.append(project_root)

from src.insight.analyze_features import main as run_feature_analysis
from src.insight.analyze_features import CONFIG as analyze_config
from src.insight.analyze_features import load_data


def select_most_important_features(k: int = 50) -> pd.DataFrame:
    """
    Select the most important features from the dataset using various methods.
    It relies on the 'feature_importance_summary.csv' generated by 'analyze_features.py'.
    If the summary file doesn't exist, it runs the feature analysis first.
    Saves the data with selected features to 'data/selected_features.csv'.
    """
    print(f"Rozpoczynam wybór {k} najważniejszych cech...")

    summary_file_path = os.path.join(analyze_config['output_dir'], 'feature_importance_summary.csv')

    if not os.path.exists(summary_file_path):
        print(f"Plik podsumowania ważności cech '{summary_file_path}' nie znaleziony.")
        print("Uruchamiam analizę cech w celu wygenerowania pliku...")
        run_feature_analysis()
        if not os.path.exists(summary_file_path):
            raise FileNotFoundError(f"Analiza cech nie utworzyła oczekiwanego pliku: {summary_file_path}")
        print("Analiza cech zakończona, plik podsumowania został wygenerowany.")

    print(f"Wczytuję podsumowanie ważności cech z: {summary_file_path}")
    # Ustawienie pierwszej kolumny jako indeksu, jeśli nie jest automatycznie rozpoznawana
    try:
        summary_df = pd.read_csv(summary_file_path, index_col=0)
    except IndexError:
         summary_df = pd.read_csv(summary_file_path)
         if summary_df.columns[0] == 'Unnamed: 0' or 'feature' in summary_df.columns[0].lower() : # common names for index col
             summary_df = summary_df.set_index(summary_df.columns[0])
         else: # Fallback if no clear index column
            print(f"Ostrzeżenie: Nie udało się automatycznie zidentyfikować kolumny indeksu w {summary_file_path}. Używam pierwszej kolumny.")
            summary_df = summary_df.set_index(summary_df.columns[0])


    if 'mean_rank' in summary_df.columns:
        # Sortuj według 'mean_rank' rosnąco (niższy ranking = ważniejsza cecha)
        sorted_features = summary_df.sort_values('mean_rank', ascending=True)
        print("Wykorzystuję 'mean_rank' do sortowania cech.")
    else:
        # Jeśli 'mean_rank' nie istnieje, znajdź pierwszą kolumnę, która nie jest rankingiem i posortuj malejąco
        importance_cols = [col for col in summary_df.columns if not col.endswith('_rank')]
        if not importance_cols:
            raise ValueError("Nie znaleziono odpowiedniej kolumny ważności w pliku podsumowania.")
        
        # Wybierz pierwszą dostępną kolumnę ważności
        # Często pierwsza kolumna po indeksie jest dobrym kandydatem
        sort_col = importance_cols[0]
        print(f"Kolumna 'mean_rank' nie znaleziona. Wykorzystuję '{sort_col}' do sortowania cech (malejąco).")
        sorted_features = summary_df.sort_values(sort_col, ascending=False)

    top_k_features = sorted_features.index[:k].tolist()
    print(f"\nWybrano {len(top_k_features)} najważniejszych cech:")
    for i, feature in enumerate(top_k_features):
        print(f"{i+1}. {feature}")

    print("\nWczytuję oryginalne przetworzone dane...")
    X, y, _ = load_data() # load_data z analyze_features

    # Sprawdź, czy wszystkie wybrane cechy istnieją w X
    missing_features = [f for f in top_k_features if f not in X.columns]
    if missing_features:
        print(f"Ostrzeżenie: Następujące wybrane cechy nie zostały znalezione w danych: {missing_features}")
        top_k_features = [f for f in top_k_features if f in X.columns]
        if not top_k_features:
            raise ValueError("Żadna z wybranych najważniejszych cech nie istnieje w załadowanych danych.")
        print(f"Kontynuuję z {len(top_k_features)} znalezionymi cechami.")


    selected_X = X[top_k_features]
    
    # Połącz wybrane cechy X z kolumną docelową y
    selected_df = pd.concat([selected_X, y.rename('ZGON')], axis=1)
    
    output_file_name = 'selected_features.csv'
    output_file_path = os.path.join(project_root, 'data', output_file_name)
    
    selected_df.to_csv(output_file_path, index=True) # Zapisz z indeksem, jeśli X go miał
    print(f"\nDane z wybranymi {len(top_k_features)} cechami zostały zapisane do: {output_file_path}")
    
    return selected_df
    

if __name__ == "__main__":
    # Ustaw k na mniejszą wartość dla szybszego testowania, jeśli to konieczne
    num_features_to_select = 50 
    print(f"Uruchamiam skrypt select_the_most_important_features.py, aby wybrać {num_features_to_select} cech.")
    try:
        selected_data = select_most_important_features(k=num_features_to_select)
        print("\nPodgląd wybranych danych:")
        print(selected_data.head())
        print(f"\nKształt wybranych danych: {selected_data.shape}")
    except Exception as e:
        print(f"Wystąpił błąd podczas wybierania cech: {e}")
        import traceback
        traceback.print_exc()
